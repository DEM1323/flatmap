<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wrapped Web Display & Projection Output</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        /* The Flat Output for Projectors */
        #shared-web-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            display: none; /* Hidden by default, shown in Projection Mode */
            z-index: 100;
            background: #000;
        }

        /* UI Overlay */
        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00f2ff;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00f2ff;
            z-index: 200;
            pointer-events: auto;
        }

        .btn {
            background: #00f2ff;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
        }

        .btn:hover { background: #fff; }

        /* VIRTUAL WEBPAGE SOURCE - This is what gets rendered to the walls */
        #webpage-source {
            position: absolute;
            top: -10000px; /* Hide from view but keep in DOM for rendering */
            width: 5120px; /* 1280 * 4 */
            height: 1440px; /* 720 * 2 */
            background: linear-gradient(45deg, #050505, #111);
            color: white;
            display: flex;
            flex-direction: column;
        }

        .panoramic-strip {
            display: flex;
            height: 720px;
            width: 5120px;
        }

        .wall-section {
            width: 1280px;
            height: 720px;
            border: 2px solid rgba(0, 242, 255, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            position: relative;
        }

        .floor-section {
            width: 1280px;
            height: 1280px; /* Square for floor */
            margin: 0 auto;
            border: 2px solid rgba(0, 242, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 242, 255, 0.05);
        }

        h1 { font-size: 80px; margin: 0; text-transform: uppercase; letter-spacing: 5px; }
        .data-point { font-size: 40px; color: #00f2ff; }
    </style>
</head>
<body>

    <div class="ui-overlay">
        <h2 style="margin: 0;">Display Manager</h2>
        <p style="font-size: 12px; opacity: 0.8;">Current Mode: <span id="mode-text">3D Preview</span></p>
        <button class="btn" onclick="toggleMode()">Switch to Projection Mode</button>
        <div style="margin-top: 10px; font-size: 11px; line-height: 1.4;">
            Wall 1-4: Top Row (Seamless)<br>
            Wall 5: Bottom Row (Floor)
        </div>
    </div>

    <!-- The physical projector output -->
    <canvas id="shared-web-canvas"></canvas>
    
    <!-- The 3D Preview container -->
    <div id="canvas-container"></div>

    <!-- VIRTUAL CONTENT: Edit this HTML to change what appears on your walls -->
    <div id="webpage-source">
        <div class="panoramic-strip">
            <div class="wall-section" style="background: linear-gradient(to right, #200, #000);">
                <h1>Wall 1</h1>
                <p class="data-point">System Boot: OK</p>
            </div>
            <div class="wall-section">
                <h1>Wall 2</h1>
                <p class="data-point">Front Interface</p>
                <div style="width: 80%; height: 10px; background: #333; margin-top: 20px;">
                    <div id="progress-bar" style="width: 50%; height: 100%; background: #00f2ff;"></div>
                </div>
            </div>
            <div class="wall-section">
                <h1>Wall 3</h1>
                <p class="data-point">Right Wing Data</p>
            </div>
            <div class="wall-section" style="background: linear-gradient(to left, #002, #000);">
                <h1>Wall 4</h1>
                <p class="data-point">Rear Sensors: Active</p>
            </div>
        </div>
        <div style="height: 720px; width: 100%; display: flex; justify-content: center;">
            <div class="floor-section">
                <div style="text-align: center;">
                    <h1>FLOOR</h1>
                    <p class="data-point" id="time-display">00:00:00</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls, cubeGroup;
        let webCanvas, webCtx, webTexture;
        let isProjectionMode = false;

        const PANEL_RES_W = 1280;
        const PANEL_RES_H = 720;

        function init() {
            setupWebCanvas();
            setup3DScene();
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function setupWebCanvas() {
            webCanvas = document.getElementById('shared-web-canvas');
            webCanvas.width = PANEL_RES_W * 4;
            webCanvas.height = PANEL_RES_H * 2;
            webCtx = webCanvas.getContext('2d');
            webTexture = new THREE.CanvasTexture(webCanvas);
        }

        function setup3DScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2.5, 1.5, 3.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);

            cubeGroup = new THREE.Group();
            
            const ASPECT_W = 1.92;
            const ASPECT_H = 1.08;
            const hW = ASPECT_W / 2;
            const hH = ASPECT_H / 2;

            const wall1 = createPanel(ASPECT_W, ASPECT_H, 0/4, 0.5, 1/4, 0.5);
            const wall2 = createPanel(ASPECT_W, ASPECT_H, 1/4, 0.5, 1/4, 0.5);
            const wall3 = createPanel(ASPECT_W, ASPECT_H, 2/4, 0.5, 1/4, 0.5);
            const wall4 = createPanel(ASPECT_W, ASPECT_H, 3/4, 0.5, 1/4, 0.5);
            const wall5 = createPanel(ASPECT_W, ASPECT_W, 0.375, 0, 0.25, 0.5);

            wall1.position.set(-hW, 0, 0); wall1.rotation.y = Math.PI/2;
            wall2.position.set(0, 0, -hW);
            wall3.position.set(hW, 0, 0); wall3.rotation.y = -Math.PI/2;
            wall4.position.set(0, 0, hW); wall4.rotation.y = Math.PI;
            wall5.position.set(0, -hH, 0); wall5.rotation.x = -Math.PI/2;

            cubeGroup.add(wall1, wall2, wall3, wall4, wall5);
            scene.add(cubeGroup);
        }

        function createPanel(w, h, u, v, uw, vh) {
            const geo = new THREE.PlaneGeometry(w, h);
            const uv = geo.attributes.uv;
            for (let i = 0; i < uv.count; i++) {
                uv.setXY(i, u + uv.getX(i) * uw, v + uv.getY(i) * vh);
            }
            return new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ map: webTexture, side: THREE.DoubleSide }));
        }

        function toggleMode() {
            isProjectionMode = !isProjectionMode;
            document.getElementById('shared-web-canvas').style.display = isProjectionMode ? 'block' : 'none';
            document.getElementById('canvas-container').style.display = isProjectionMode ? 'none' : 'block';
            document.getElementById('mode-text').innerText = isProjectionMode ? 'PROJECTION (Flat)' : '3D Preview';
        }

        function updateWebpageContent() {
            // Update live data in the virtual DOM
            const now = new Date();
            document.getElementById('time-display').innerText = now.toTimeString().split(' ')[0];
            document.getElementById('progress-bar').style.width = ((Date.now() / 50) % 100) + "%";

            // Use html2canvas to capture the virtual DOM and draw to the shared texture
            // For production with projectors, you'd likely use a high-speed canvas drawing loop
            // instead of html2canvas for performance, but this shows how to render "HTML".
            
            // To keep it high-performance for this demo, we'll draw directly to webCtx
            // mimicking the layout of the #webpage-source
            
            const time = Date.now() * 0.001;
            webCtx.fillStyle = '#050505';
            webCtx.fillRect(0, 0, webCanvas.width, webCanvas.height);

            // Simulate the seamless wrap across 1-4
            webCtx.fillStyle = '#fff';
            webCtx.textAlign = 'center';
            webCtx.font = 'bold 100px sans-serif';
            
            // Draw text that travels across the walls
            const xPos = (time * 150) % (webCanvas.width + 1000) - 500;
            webCtx.globalAlpha = 0.3;
            webCtx.fillText("SYSTEM STATUS: NOMINAL • SEAMLESS CALIBRATION ACTIVE • ", xPos, 400);
            webCtx.globalAlpha = 1.0;

            // Draw Wall Dividers for testing alignment
            webCtx.strokeStyle = '#00f2ff';
            webCtx.lineWidth = 5;
            for(let i=0; i<=4; i++) {
                webCtx.beginPath();
                webCtx.moveTo(i * PANEL_RES_W, 0);
                webCtx.lineTo(i * PANEL_RES_W, PANEL_RES_H);
                webCtx.stroke();
                if(i < 4) webCtx.fillText(i+1, (i+0.5)*PANEL_RES_W, 200);
            }

            // Floor Area (Wall 5)
            const fX = PANEL_RES_W * 1.5;
            const fY = PANEL_RES_H;
            webCtx.strokeRect(fX, fY, PANEL_RES_W, PANEL_RES_W);
            webCtx.fillText("5", fX + PANEL_RES_W/2, fY + PANEL_RES_W/2);

            webTexture.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateWebpageContent();
            if (!isProjectionMode) controls.update();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
